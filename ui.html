<h2>Completed Puzzle Creator</h2>
<p>Rows: <input id="rows" type="number" value="3" min="1" max="10"></p>
<p>Columns: <input id="columns" type="number" value="3" min="1" max="10"></p>
<p>Image: <input id="image" type="file" accept="image/*"></p>
<div id="image-preview" style="margin: 10px 0; text-align: center;"></div>
<div id="puzzle-preview" style="margin: 10px 0; text-align: center;"></div>

<button id="create">Create Completed Puzzle</button>
<button id="cancel">Cancel</button>
<script>

let currentImage = null;
let puzzlePieces = [];

// Handle image preview and puzzle piece generation
document.getElementById('image').onchange = (event) => {
  const file = event.target.files[0];
  const preview = document.getElementById('image-preview');
  
  if (file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        currentImage = img;
        preview.innerHTML = `<img src="${e.target.result}" style="max-width: 200px; max-height: 100px; border: 1px solid #ccc;">`;
        generatePuzzlePreview();
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  } else {
    preview.innerHTML = '';
    document.getElementById('puzzle-preview').innerHTML = '';
    currentImage = null;
    puzzlePieces = [];
  }
};

// Update puzzle preview when rows/columns change
document.getElementById('rows').onchange = generatePuzzlePreview;
document.getElementById('columns').onchange = generatePuzzlePreview;

function generatePuzzlePreview() {
  if (!currentImage) return;
  
  const rows = parseInt(document.getElementById('rows').value, 10);
  const columns = parseInt(document.getElementById('columns').value, 10);
  const puzzlePreview = document.getElementById('puzzle-preview');
  
  // Create canvas to crop image pieces
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // Calculate piece dimensions
  const pieceWidth = currentImage.width / columns;
  const pieceHeight = currentImage.height / rows;
  
  canvas.width = pieceWidth;
  canvas.height = pieceHeight;
  
  puzzlePieces = [];
  
  // Calculate preview dimensions while maintaining aspect ratio
  const maxPreviewWidth = 200; // Maximum width for the entire preview
  const aspectRatio = currentImage.width / currentImage.height;
  let previewWidth, previewHeight;
  
  if (aspectRatio > 1) {
    // Landscape image
    previewWidth = Math.min(maxPreviewWidth, currentImage.width);
    previewHeight = previewWidth / aspectRatio;
  } else {
    // Portrait or square image
    previewHeight = Math.min(maxPreviewWidth, currentImage.height);
    previewWidth = previewHeight * aspectRatio;
  }
  
  const previewPieceWidth = previewWidth / columns;
  const previewPieceHeight = previewHeight / rows;
  
  let previewHTML = `<div style="display: inline-block; border: 1px solid #ddd; padding: 5px;"><h4>Puzzle Preview (${currentImage.width}Ã—${currentImage.height}px):</h4>`;
  
  for (let row = 0; row < rows; row++) {
    previewHTML += '<div style="line-height: 0;">';
    for (let col = 0; col < columns; col++) {
      // Clear canvas
      ctx.clearRect(0, 0, pieceWidth, pieceHeight);
      
      // Draw the cropped piece
      ctx.drawImage(
        currentImage,
        col * pieceWidth, row * pieceHeight, pieceWidth, pieceHeight, // source
        0, 0, pieceWidth, pieceHeight // destination
      );
      
      // Convert to blob and store
      const pieceDataURL = canvas.toDataURL('image/png');
      puzzlePieces.push({
        row: row,
        col: col,
        dataURL: pieceDataURL
      });
      
      // Add to preview with correct proportions
      previewHTML += `<img src="${pieceDataURL}" style="width: ${previewPieceWidth}px; height: ${previewPieceHeight}px; margin: 0; border: 1px solid #999; display: inline-block;">`;
    }
    previewHTML += '</div>';
  }
  
  previewHTML += '</div>';
  puzzlePreview.innerHTML = previewHTML;
}

document.getElementById('create').onclick = async () => {
  const rows = parseInt(document.getElementById('rows').value, 10);
  const columns = parseInt(document.getElementById('columns').value, 10);
  
  if (currentImage) {
    // Create cropped pieces
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Calculate piece dimensions
    const pieceWidth = currentImage.width / columns;
    const pieceHeight = currentImage.height / rows;
    
    canvas.width = pieceWidth;
    canvas.height = pieceHeight;
    
    const puzzleData = [];
    
    // Create each cropped piece
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        // Clear canvas
        ctx.clearRect(0, 0, pieceWidth, pieceHeight);
        
        // Draw the cropped piece
        ctx.drawImage(
          currentImage,
          col * pieceWidth, row * pieceHeight, pieceWidth, pieceHeight, // source
          0, 0, pieceWidth, pieceHeight // destination
        );
        
        // Convert to blob and then to ArrayBuffer
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
        const arrayBuffer = await blob.arrayBuffer();
        
        puzzleData.push({
          row: row,
          col: col,
          imageData: arrayBuffer
        });
      }
    }
    
    parent.postMessage({ 
      pluginMessage: { 
        type: 'create-puzzle', 
        rows, 
        columns, 
        puzzleData: puzzleData,
        originalImageWidth: currentImage.width,
        originalImageHeight: currentImage.height
      } 
    }, '*');
  } else {
    // No image selected, proceed without image
    parent.postMessage({ 
      pluginMessage: { 
        type: 'create-shapes', 
        rows, 
        columns 
      } 
    }, '*');
  }
}

document.getElementById('cancel').onclick = () => {
  parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*')
}

</script>
