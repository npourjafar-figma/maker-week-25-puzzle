<head>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Arial', sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 20px;
    color: #333;
  }

  .container {
    max-width: 400px;
    margin: 0 auto;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    animation: slideIn 0.6s ease-out;
  }

  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateY(30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  h2 {
    text-align: center;
    background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #f9ca24);
    background-size: 300% 300%;
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: gradientShift 3s ease infinite;
    font-size: 24px;
    margin-bottom: 25px;
    font-weight: bold;
  }

  @keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }

  .form-group {
    margin-bottom: 20px;
  }

  label {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
    color: #555;
    font-size: 14px;
  }

  input[type="number"], input[type="file"] {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid #e1e8ed;
    border-radius: 12px;
    font-size: 16px;
    transition: all 0.3s ease;
    background: #fff;
  }

  input[type="number"]:focus, input[type="file"]:focus {
    outline: none;
    border-color: #4ecdc4;
    box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.2);
    transform: translateY(-2px);
  }

  input[type="file"] {
    cursor: pointer;
    position: relative;
  }

  input[type="file"]:hover {
    background: #f8f9fa;
    border-color: #4ecdc4;
  }

  .preview-container {
    margin: 20px 0;
    text-align: center;
  }

  .preview-box {
    background: #f8f9fa;
    border: 2px dashed #ddd;
    border-radius: 12px;
    padding: 15px;
    margin: 10px 0;
    transition: all 0.3s ease;
  }

  .preview-box:not(:empty) {
    border-color: #4ecdc4;
    background: rgba(78, 205, 196, 0.05);
  }

  .preview-box img {
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .button-container {
    display: flex;
    gap: 10px;
    margin-top: 25px;
  }

  button {
    flex: 1;
    padding: 14px 20px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }

  button:before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    transition: left 0.5s;
  }

  button:hover:before {
    left: 100%;
  }

  #create {
    background: linear-gradient(135deg, #ff6b6b, #ee5a24);
    color: white;
    box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
  }

  #create:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
  }

  #create:active {
    transform: translateY(-1px);
  }



  #debug {
    background: linear-gradient(135deg, #a29bfe, #6c5ce7);
    color: white;
    box-shadow: 0 6px 20px rgba(162, 155, 254, 0.4);
    font-size: 14px;
  }

  #debug:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(162, 155, 254, 0.6);
  }

  .puzzle-info {
    text-align: center;
    margin: 15px 0;
    padding: 12px;
    background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
    border-radius: 10px;
    font-size: 14px;
    font-weight: bold;
    color: #2d3436;
    border: 2px solid #fdcb6e;
  }

  .emoji {
    font-size: 20px;
    margin: 0 5px;
  }

  /* Fun loading animation for preview */
  .loading {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid #f3f3f3;
    border-top: 3px solid #4ecdc4;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Puzzle piece icons */
  .puzzle-icon {
    display: inline-block;
    margin: 0 5px;
    font-size: 18px;
    animation: bounce 2s infinite;
  }

  @keyframes bounce {
    0%, 20%, 50%, 80%, 100% {
      transform: translateY(0);
    }
    40% {
      transform: translateY(-5px);
    }
    60% {
      transform: translateY(-3px);
    }
  }
</style>
</head>

<body>
<div class="container">
  <h2><span class="puzzle-icon">üß©</span>Figma Puzzle Creator<span class="puzzle-icon">üß©</span></h2>
  
  <div class="form-group">
    <label for="rows"><span class="emoji">üìè</span>Rows:</label>
    <input id="rows" type="number" value="4" min="1" max="10">
  </div>
  
  <div class="form-group">
    <label for="columns"><span class="emoji">üìê</span>Columns:</label>
    <input id="columns" type="number" value="3" min="1" max="10">
  </div>
  
  <div class="form-group">
    <label for="image"><span class="emoji">üñºÔ∏è</span>Choose Your Image:</label>
    <input id="image" type="file" accept="image/*">
  </div>
  
  <div class="preview-container">
    <div id="image-preview" class="preview-box"></div>
    <div id="puzzle-preview" class="preview-box"></div>
  </div>

  <div class="button-container">
    <button id="create"><span class="emoji">üöÄ</span>Create Puzzle</button>
    <button id="debug"><span class="emoji">üêõ</span>Debug</button>
  </div>
</div>

<script>

let currentImage = null;
let puzzlePieces = [];

// Handle image preview and puzzle piece generation
document.getElementById('image').onchange = (event) => {
  const file = event.target.files[0];
  const preview = document.getElementById('image-preview');
  
  if (file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        currentImage = img;
        preview.innerHTML = `<img src="${e.target.result}" style="max-width: 200px; max-height: 100px; border: 1px solid #ccc;">`;
        generatePuzzlePreview();
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  } else {
    preview.innerHTML = '';
    document.getElementById('puzzle-preview').innerHTML = '';
    currentImage = null;
    puzzlePieces = [];
  }
};

// Update puzzle preview when rows/columns change
document.getElementById('rows').onchange = generatePuzzlePreview;
document.getElementById('columns').onchange = generatePuzzlePreview;

function generatePuzzlePreview() {
  if (!currentImage) return;
  
  const rows = parseInt(document.getElementById('rows').value, 10);
  const columns = parseInt(document.getElementById('columns').value, 10);
  const puzzlePreview = document.getElementById('puzzle-preview');
  
  // Create canvas to crop image pieces
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // Calculate piece dimensions
  const pieceWidth = currentImage.width / columns;
  const pieceHeight = currentImage.height / rows;
  
  canvas.width = pieceWidth;
  canvas.height = pieceHeight;
  
  puzzlePieces = [];
  
  // Calculate preview dimensions while maintaining aspect ratio
  const maxPreviewWidth = 200; // Maximum width for the entire preview
  const aspectRatio = currentImage.width / currentImage.height;
  let previewWidth, previewHeight;
  
  if (aspectRatio > 1) {
    // Landscape image
    previewWidth = Math.min(maxPreviewWidth, currentImage.width);
    previewHeight = previewWidth / aspectRatio;
  } else {
    // Portrait or square image
    previewHeight = Math.min(maxPreviewWidth, currentImage.height);
    previewWidth = previewHeight * aspectRatio;
  }
  
  const previewPieceWidth = previewWidth / columns;
  const previewPieceHeight = previewHeight / rows;
  
  let previewHTML = `<div class="puzzle-info"><span class="emoji">üéØ</span>Puzzle Preview (${currentImage.width}√ó${currentImage.height}px)<span class="emoji">üéØ</span></div>`;
  
  for (let row = 0; row < rows; row++) {
    previewHTML += '<div style="line-height: 0;">';
    for (let col = 0; col < columns; col++) {
      // Clear canvas
      ctx.clearRect(0, 0, pieceWidth, pieceHeight);
      
      // Draw the cropped piece
      ctx.drawImage(
        currentImage,
        col * pieceWidth, row * pieceHeight, pieceWidth, pieceHeight, // source
        0, 0, pieceWidth, pieceHeight // destination
      );
      
      // Convert to blob and store
      const pieceDataURL = canvas.toDataURL('image/png');
      puzzlePieces.push({
        row: row,
        col: col,
        dataURL: pieceDataURL
      });
      
      // Add to preview with correct proportions
      previewHTML += `<img src="${pieceDataURL}" style="width: ${previewPieceWidth}px; height: ${previewPieceHeight}px; margin: 0; border: 1px solid #999; display: inline-block;">`;
    }
    previewHTML += '</div>';
  }
  
  puzzlePreview.innerHTML = previewHTML;
}

document.getElementById('create').onclick = async () => {
  const rows = parseInt(document.getElementById('rows').value, 10);
  const columns = parseInt(document.getElementById('columns').value, 10);
  
  if (currentImage) {
    // Create cropped pieces
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Calculate piece dimensions
    const pieceWidth = currentImage.width / columns;
    const pieceHeight = currentImage.height / rows;
    const D = Math.min(pieceWidth, pieceHeight)/4

    canvas.width = pieceWidth+2*D;
    canvas.height = pieceHeight+2*D;
    const puzzleData = [];
    
    // Create each cropped piece
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < columns; col++) {
        // Clear canvas
        ctx.clearRect(0, 0, pieceWidth+2*D, pieceHeight+2*D);
        
        // Draw the cropped piece
        ctx.drawImage(
          currentImage,
          col * pieceWidth-D, row * pieceHeight-D, pieceWidth+2*D, pieceHeight+2*D, // source
          0, 0, pieceWidth+2*D, pieceHeight+2*D // destination
        );
        
        // Convert to blob and then to ArrayBuffer
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
        const arrayBuffer = await blob.arrayBuffer();
        
        puzzleData.push({
          row: row,
          col: col,
          imageData: arrayBuffer
        });
      }
    }
    
    parent.postMessage({ 
      pluginMessage: { 
        type: 'create-puzzle', 
        rows, 
        columns, 
        puzzleData: puzzleData,
        originalImageWidth: currentImage.width,
        originalImageHeight: currentImage.height
      } 
    }, '*');
  } else {
    // No image selected, proceed without image
    parent.postMessage({ 
      pluginMessage: { 
        type: 'create-shapes', 
        rows, 
        columns 
      } 
    }, '*');
  }
}



document.getElementById('debug').onclick = () => {
  parent.postMessage({ pluginMessage: { type: 'debug' } }, '*')
}

</script>
</body>
